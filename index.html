<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>incre_ment</title>
  <style>
    body { background-color: #0a0a0a; color: #f0f0f0; font-family: sans-serif; margin: 0; padding: 40px 20px; }
    .gallery { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 30px; max-width: 1200px; margin: 0 auto; }
    .card { background: #151515; border: 1px solid #222; border-radius: 4px; overflow: hidden; display: flex; flex-direction: column; transition: transform 0.3s ease; }
    .card:hover { transform: translateY(-5px); border-color: #444; }
    #shader-canvas { width: 100%; aspect-ratio: 1 / 1; display: block; background-color: #000; }
    .card-info { padding: 15px; }
    .card-title { font-size: 1rem; margin: 0; color: #ddd; }
  </style>
</head>
<body>

  <header style="text-align: center; margin-bottom: 60px;">
    <h1 style="font-weight: 200; letter-spacing: 4px; text-transform: uppercase;">incre_ment</h1>
    <p style="color: #666; font-size: 0.9rem;">Native WebGL Implementation</p>
  </header>

  <main class="gallery">
    <div class="card">
      <canvas id="shader-canvas" width="800" height="800"></canvas>
      <div class="card-info">
        <p class="card-title">Rotating Triangles</p>
      </div>
    </div>
  </main>

  <script type="module">
    const canvas = document.getElementById('shader-canvas');
    const gl = canvas.getContext('webgl');

    const vertexSource = `
        attribute vec2 position;
        void main() { gl_Position = vec4(position, 0.0, 1.0); }
    `;

    const fragmentSource = `
        precision mediump float;
        uniform vec2 u_resolution;
        uniform float u_time;

        #define rotation(angle) mat2(cos(angle), -sin(angle), sin(angle), cos(angle))
        float TAU = 2.*3.14159;

        float eqTri( in vec2 p, in float r ) {
            const float k = sqrt(3.0);
            p.x = abs(p.x) - r;
            p.y = p.y + r/k;
            if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;
            p.x -= clamp( p.x, -2.0*r, 0.0 );
            return -length(p)*sign(p.y);
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy - .5 * u_resolution.xy) / u_resolution.y;
            vec3 col = vec3(0.);
            float t = fract(.1 * u_time);
            uv *= rotation(3. * TAU * (.3 - clamp(length(uv),0.,.3)));
            float s = -1.;
            for(float i = 0.; i < 3.; i++){
                float rad = .4 / pow(2.,i) * (.9 - .2 * i);
                uv *= rotation(-2. * s * (i + 1.) * TAU * t);
                float tri = eqTri(uv, rad);
                s *= -1.;
                col += .004 / abs(tri);
            }
            gl_FragColor = vec4(col, 1.0);
        }
    `;

    // Boilerplate to set up the GPU program
    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(shader));
        }
        return shader;
    }

    const program = gl.createProgram();
    gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vertexSource));
    gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fragmentSource));
    gl.linkProgram(program);
    gl.useProgram(program);

    // Create a square plane for the shader to draw on
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);

    const positionLocation = gl.getAttribLocation(program, "position");
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    // Get locations for our Time and Resolution variables
    const timeLoc = gl.getUniformLocation(program, "u_time");
    const resLoc = gl.getUniformLocation(program, "u_resolution");

    function render(time) {
        gl.viewport(0, 0, canvas.width, canvas.height);
        
        // Update Time (seconds) and Resolution
        gl.uniform1f(timeLoc, time * 0.001);
        gl.uniform2f(resLoc, canvas.width, canvas.height);

        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
  </script>
</body>
</html>
